# Telusko-Day-6
Annotations

# Output of AnnotationExample.java

![1](https://github.com/Vyankatesh-Telusko/Telusko-Day-6/assets/134121798/393a748e-c3d9-4ab2-8602-a665ebeedd0f)

# Study

In Java, annotations are a form of metadata that provide additional information about elements in your code, such as classes, methods, fields, or parameters. They can be used by the compiler, runtime, or other tools to process or analyze the annotated code. Annotations are marked using the @ symbol followed by the annotation name.

Java annotations can be either built-in annotations provided by the Java language or custom annotations created by developers.

Here are some commonly used built-in annotations in Java:
1. @Override: This annotation is used to indicate that a method in a subclass is intended to override a method in its superclass. It helps in detecting accidental method signature changes that may occur during refactoring.
2. @Deprecated: This annotation marks a program element (such as a class, method, or field) as deprecated, indicating that it is no longer recommended for use. It serves as a warning to developers who use the deprecated element.
3. @SuppressWarnings: This annotation suppresses compiler warnings for a specific code element or a whole block of code. It is used when you want to ignore specific warnings that would otherwise be generated by the compiler.
4. @FunctionalInterface: This annotation is used to indicate that an interface is intended to be a functional interface, i.e., an interface with a single abstract method. It helps to enforce the single method contract for functional interfaces used with lambda expressions or method references.


In addition to these, Java also provides other annotations for purposes such as runtime retention, parameter validation, thread safety, and more. Custom annotations can be created using the @interface keyword, allowing developers to define their own annotations with custom elements.

Custom annotations can be used for various purposes, such as defining application-specific metadata, enabling configuration options, or providing instructions for code generation tools. They can be accessed and processed at runtime using reflection or used by other tools for static analysis, documentation generation, or code generation.

## Eg.01
## Code:
##### import java.lang.annotation.*;

##### // Define a custom annotation
##### @Retention(RetentionPolicy.RUNTIME)
##### @Target(ElementType.METHOD)
##### public @interface CustomAnnotation {
#####     String value() default ""; // Define an element within the annotation
##### }
## Explaination
In the above code:

* The @Retention annotation specifies that the custom annotation should be retained at runtime, allowing it to be accessed and processed using reflection.
* The @Target annotation specifies that the custom annotation can only be applied to methods (ElementType.METHOD), but you can change it to other element types like classes or fields as per your requirements.
* The @interface keyword is used to declare a custom annotation named CustomAnnotation.
* The value() method is defined as an element within the annotation. You can define additional elements based on your needs.

## Eg.02
Once you've defined the custom annotation, you can use it in your code. Here's an example of how you can apply the custom annotation to a method:
## Code:
##### public class MyClass {
#####     @CustomAnnotation("Hello, Custom Annotation!")
#####     public void myMethod() {
#####         // Method implementation
#####     }
##### }
## Explaination:
In the above code, the myMethod() is annotated with @CustomAnnotation, and the element value is set to the string "Hello, Custom Annotation!".

## Eg.03
To access and process the custom annotation at runtime, you can use reflection. Here's an example of how you can retrieve the annotation value from the annotated method:
## Code:
##### import java.lang.reflect.*;

##### public class Main {
#####     public static void main(String[] args) throws NoSuchMethodException {
#####         Method method = MyClass.class.getMethod("myMethod");
#####         CustomAnnotation annotation = method.getAnnotation(CustomAnnotation.class);
#####         String value = annotation.value();
#####         System.out.println(value);
#####     }
##### }
## Explaination:
In the above code, we obtain the Method object for the myMethod() method using reflection. Then, we use the getAnnotation() method to retrieve the CustomAnnotation instance from the method. Finally, we can access the value of the annotation using the value() method.

Keep in mind that custom annotations in Java can be used for various purposes, and their behavior depends on how you process or interpret them in your code or tools.
